{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "processing-card",
  "type": "registry:block",
  "title": "Processing Card",
  "description": "Animated processing card with glitch effects, progress tracking, and status indicators",
  "dependencies": [
    "framer-motion",
    "lucide-react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/processing-card/processing-card.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { Monitor } from 'lucide-react'\n\n// tiny util\nfunction cn(...classes: (string | undefined | null | false)[]) {\n  return classes.filter(Boolean).join(' ')\n}\n\n/* ────────────── LetterGlitch ────────────── */\nconst LetterGlitch: React.FC<{\n  glitchColors?: string[]\n  glitchSpeed?: number\n  centerVignette?: boolean\n  outerVignette?: boolean\n  smooth?: boolean\n  characters?: string\n  className?: string\n}> = ({\n  glitchColors = ['#78b4ff', '#a0c4ff', '#c7d2fe', '#e0e7ff', '#f0f4ff'],\n  glitchSpeed = 50,\n  centerVignette = false,\n  outerVignette = true,\n  smooth = true,\n  characters = '.,:;-*#',\n  className = ''\n}) => {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null)\n  const animationRef = React.useRef<number | null>(null)\n  const letters = React.useRef<\n    Array<{ char: string; color: string; targetColor: string; colorProgress: number }>\n  >([])\n  const grid = React.useRef({ columns: 0, rows: 0 })\n  const context = React.useRef<CanvasRenderingContext2D | null>(null)\n  const lastGlitchTime = React.useRef(Date.now())\n\n  const lettersAndSymbols = React.useMemo(() => Array.from(characters), [characters])\n  const fontSize = 16\n  const charWidth = 10\n  const charHeight = 20\n\n  const getRandomChar = React.useCallback(\n    () => lettersAndSymbols[Math.floor(Math.random() * lettersAndSymbols.length)],\n    [lettersAndSymbols]\n  )\n  const getRandomColor = React.useCallback(\n    () => glitchColors[Math.floor(Math.random() * glitchColors.length)],\n    [glitchColors]\n  )\n\n  const hexToRgb = (hex: string) => {\n    const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i\n    const normalized = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b)\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(normalized)\n    return result\n      ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) }\n      : null\n  }\n\n  const interpolateColor = (\n    start: { r: number; g: number; b: number },\n    end: { r: number; g: number; b: number },\n    factor: number\n  ) =>\n    `rgb(${Math.round(start.r + (end.r - start.r) * factor)},${Math.round(\n      start.g + (end.g - start.g) * factor\n    )},${Math.round(start.b + (end.b - start.b) * factor)})`\n\n  const calculateGrid = (width: number, height: number) => ({\n    columns: Math.ceil(width / charWidth),\n    rows: Math.ceil(height / charHeight)\n  })\n\n  const initializeLetters = (columns: number, rows: number) => {\n    grid.current = { columns, rows }\n    const total = columns * rows\n    letters.current = Array.from({ length: total }, () => ({\n      char: getRandomChar(),\n      color: getRandomColor(),\n      targetColor: getRandomColor(),\n      colorProgress: 1\n    }))\n  }\n\n  const drawLetters = () => {\n    if (!context.current || !canvasRef.current) return\n    const ctx = context.current\n    const canvas = canvasRef.current\n    // Use canvas dimensions, not getBoundingClientRect\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    ctx.font = `${fontSize}px monospace`\n    ctx.textBaseline = 'top'\n    letters.current.forEach((letter, index) => {\n      const x = (index % grid.current.columns) * charWidth\n      const y = Math.floor(index / grid.current.columns) * charHeight\n      ctx.fillStyle = letter.color\n      ctx.fillText(letter.char, x, y)\n    })\n  }\n\n  const updateLetters = () => {\n    const updateCount = Math.max(1, Math.floor(letters.current.length * 0.05))\n    for (let i = 0; i < updateCount; i++) {\n      const idx = Math.floor(Math.random() * letters.current.length)\n      const item = letters.current[idx]\n      item.char = getRandomChar()\n      item.targetColor = getRandomColor()\n      if (!smooth) {\n        item.color = item.targetColor\n        item.colorProgress = 1\n      } else {\n        item.colorProgress = 0\n      }\n    }\n  }\n\n  const handleSmoothTransitions = () => {\n    let needsRedraw = false\n    letters.current.forEach(letter => {\n      if (letter.colorProgress < 1) {\n        const startRgb = hexToRgb(letter.color)\n        const endRgb = hexToRgb(letter.targetColor)\n        letter.colorProgress = Math.min(1, letter.colorProgress + 0.05)\n        if (startRgb && endRgb) {\n          letter.color = interpolateColor(startRgb, endRgb, letter.colorProgress)\n          needsRedraw = true\n        }\n      }\n    })\n    if (needsRedraw) drawLetters()\n  }\n\n  const animate = () => {\n    const now = Date.now()\n    if (now - lastGlitchTime.current >= glitchSpeed) {\n      updateLetters()\n      drawLetters()\n      lastGlitchTime.current = now\n    }\n    if (smooth) handleSmoothTransitions()\n    animationRef.current = requestAnimationFrame(animate)\n  }\n\n  const resizeCanvas = () => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n    const parent = canvas.parentElement\n    if (!parent) return\n    const dpr = window.devicePixelRatio || 1\n    \n    // Force parent to have dimensions\n    const rect = parent.getBoundingClientRect()\n    const width = rect.width || parent.clientWidth || parent.offsetWidth\n    const height = rect.height || parent.clientHeight || parent.offsetHeight\n    \n    // Set canvas size with DPR\n    canvas.width = width * dpr\n    canvas.height = height * dpr\n    canvas.style.width = `${width}px`\n    canvas.style.height = `${height}px`\n    \n    // Reset transform and calculate grid with visual dimensions\n    if (context.current) context.current.setTransform(dpr, 0, 0, dpr, 0, 0)\n    const { columns, rows } = calculateGrid(width, height)\n    initializeLetters(columns, rows)\n    drawLetters()\n  }\n\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n    context.current = canvas.getContext('2d')\n    resizeCanvas()\n    animate()\n\n    let resizeTimeout: number | undefined\n    const handleResize = () => {\n      if (resizeTimeout) window.clearTimeout(resizeTimeout)\n      resizeTimeout = window.setTimeout(() => {\n        if (animationRef.current) cancelAnimationFrame(animationRef.current)\n        resizeCanvas()\n        animate()\n      }, 100)\n    }\n    window.addEventListener('resize', handleResize)\n    return () => {\n      if (animationRef.current) cancelAnimationFrame(animationRef.current)\n      window.removeEventListener('resize', handleResize)\n    }\n  }, [glitchSpeed, smooth])\n\n  return (\n    <div className={cn('relative w-full h-full bg-black overflow-hidden', className)}>\n      <canvas ref={canvasRef} className=\"absolute inset-0 w-full h-full\" />\n      {outerVignette && (\n        <div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0)_60%,_rgba(0,0,0,1)_100%)]\" />\n      )}\n      {centerVignette && (\n        <div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]\" />\n      )}\n    </div>\n  )\n}\n\n/* ────────────── CustomLoader ────────────── */\nconst loaderStyle = `\n.custom-loader-5{height:32px;width:32px;position:relative;animation:loader-5-1 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}\n@keyframes loader-5-1{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n.custom-loader-5::before,.custom-loader-5::after,.custom-loader-5 span::before,.custom-loader-5 span::after{\ncontent:\"\";display:block;position:absolute;margin:auto;background:#78b4ff;border-radius:50%}\n.custom-loader-5::before{top:0;left:0;bottom:0;right:auto;width:8px;height:8px;animation:loader-5-2 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}\n@keyframes loader-5-2{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(24px,0,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}\n.custom-loader-5::after{top:0;left:auto;bottom:0;right:0;width:8px;height:8px;animation:loader-5-3 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}\n@keyframes loader-5-3{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(-24px,0,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}\n.custom-loader-5 span{display:block;position:absolute;top:0;left:0;bottom:0;right:0;margin:auto;height:32px;width:32px}\n.custom-loader-5 span::before{top:0;left:0;bottom:auto;right:0;width:8px;height:8px;animation:loader-5-4 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}\n@keyframes loader-5-4{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(0,24px,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}\n.custom-loader-5 span::after{top:auto;left:0;bottom:0;right:0;width:8px;height:8px;animation:loader-5-5 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}\n@keyframes loader-5-5{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(0,-24px,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}`\nif (typeof document !== 'undefined' && !document.getElementById('loader-style')) {\n  const styleTag = document.createElement('style')\n  styleTag.id = 'loader-style'\n  styleTag.innerHTML = loaderStyle\n  document.head.appendChild(styleTag)\n}\nconst CustomLoader: React.FC<{ className?: string; size?: 'sm' | 'md' | 'lg' }> = ({\n  className,\n  size = 'md'\n}) => <div className={cn(`custom-loader-5 size-${size}`, className)}><span /></div>\n\n/* ────────────── AsciiProgressBar ────────────── */\nconst AsciiProgressBar: React.FC<{ progress: number; className?: string }> = ({\n  progress,\n  className\n}) => {\n  const [animatedProgress, setAnimatedProgress] = React.useState(0)\n  React.useEffect(() => {\n    const t = setTimeout(() => setAnimatedProgress(progress), 100)\n    return () => clearTimeout(t)\n  }, [progress])\n  const totalBars = 20\n  const filledBars = Math.floor((animatedProgress / 100) * totalBars)\n  const characters = Array.from({ length: totalBars }, (_, index) => ({\n    char: index < filledBars ? '▓' : '░',\n    isFilled: index < filledBars,\n    index\n  }))\n  return (\n    <div className={cn('font-mono text-lg', className)}>\n      <div className=\"flex items-center text-white/80\">\n        <span className=\"text-white/60 mr-1\">[</span>\n        <div className=\"flex\">\n          {characters.map((item, index) => (\n            <motion.span\n              key={index}\n              initial={{ opacity: 0.3 }}\n              animate={{ opacity: 1, scale: item.isFilled ? [1, 1.2, 1] : 1 }}\n              transition={{\n                delay: item.isFilled ? index * 0.03 : 0,\n                duration: item.isFilled ? 0.3 : 0.1,\n                scale: { repeat: item.isFilled ? 1 : 0, duration: 0.4 }\n              }}\n              className={item.isFilled ? 'text-[#78b4ff]' : 'text-white/30'}\n            >\n              {item.char}\n            </motion.span>\n          ))}\n        </div>\n        <span className=\"text-white/60 ml-1\">]</span>\n        <span className=\"text-white/60 ml-2 text-sm\">\n          {Math.round(animatedProgress)}%\n        </span>\n      </div>\n    </div>\n  )\n}\n\n/* ────────────── ProcessingCard ────────────── */\ninterface ProcessingCardProps {\n  name?: string\n  className?: string\n  status?: 'queued' | 'running' | 'succeeded' | 'failed'\n  progress?: number\n  glitchOffsetX?: number\n  glitchOffsetY?: number\n  glitchScale?: number\n  cardWidth?: number\n  cardHeight?: number\n}\n\nconst processingStages = [\n  { key: 'initializing', label: 'Initializing...', minProgress: 0 },\n  { key: 'analyzing', label: 'Analyzing components...', minProgress: 10 },\n  { key: 'generating', label: 'Generating TSX code...', minProgress: 30 },\n  { key: 'validating', label: 'Validating syntax...', minProgress: 70 },\n  { key: 'optimizing', label: 'Optimizing code...', minProgress: 85 },\n  { key: 'finalizing', label: 'Finalizing...', minProgress: 95 }\n]\n\nconst getCurrentStage = (progress: number) => {\n  for (let i = processingStages.length - 1; i >= 0; i--) {\n    if (progress >= processingStages[i].minProgress) return processingStages[i]\n  }\n  return processingStages[0]\n}\n\nconst ProcessingCard: React.FC<ProcessingCardProps> = ({\n  name = 'ComponentGeneration',\n  className,\n  status = 'queued',\n  progress = 0,\n  glitchOffsetX = 0,\n  glitchOffsetY = 0,\n  glitchScale = 1,\n  cardWidth,\n  cardHeight = 400\n}) => {\n  const [displayProgress, setDisplayProgress] = React.useState(0)\n  const [currentStage, setCurrentStage] = React.useState(processingStages[0])\n\n  React.useEffect(() => {\n    const t = setTimeout(() => setDisplayProgress(progress), 100)\n    return () => clearTimeout(t)\n  }, [progress])\n\n  React.useEffect(() => {\n    setCurrentStage(getCurrentStage(displayProgress))\n  }, [displayProgress])\n\n  React.useEffect(() => {\n    if (status === 'running' && displayProgress < 95) {\n      const i = setInterval(() => {\n        setDisplayProgress(prev =>\n          Math.min(prev + Math.random() * 2 + 0.5, Math.min(progress + 10, 95))\n        )\n      }, 500)\n      return () => clearInterval(i)\n    }\n  }, [status, progress, displayProgress])\n\n  const finalProgress = status === 'succeeded' ? 100 : displayProgress\n  const getStatusText = () =>\n    status === 'queued'\n      ? 'Queued for processing...'\n      : status === 'running'\n      ? currentStage.label\n      : status === 'succeeded'\n      ? 'Generation completed!'\n      : status === 'failed'\n      ? 'Generation failed'\n      : 'Processing...'\n\n  return (\n    <div\n      className={cn(\n        'w-full rounded-2xl border overflow-hidden shadow-lg',\n        // ALWAYS dark palette:\n        'bg-[#0b0b0f] text-white border-white/10',\n        className\n      )}\n      style={cardWidth ? { maxWidth: `${cardWidth}px` } : undefined}\n    >\n      {/* Header (dark) */}\n      <div className=\"flex items-center justify-between px-4 py-3 border-b border-white/10\">\n        <div className=\"text-sm font-medium text-white truncate\">{name}.tsx</div>\n        {(status === 'running' || status === 'queued' || status === 'succeeded') && (\n          <div className=\"text-xs text-white/60\">{Math.round(finalProgress)}%</div>\n        )}\n      </div>\n\n      {/* Inner content — ALWAYS dark */}\n      <div \n        className=\"relative w-full bg-black text-white overflow-hidden\"\n        style={{ height: `${cardHeight}px` }}\n      >\n        {/* ASCII glitch backdrop */}\n        <div \n          className=\"absolute inset-0 w-full h-full opacity-25 z-10\"\n          style={{\n            transform: `translate(${glitchOffsetX}px, ${glitchOffsetY}px) scale(${glitchScale})`,\n            transformOrigin: 'center center'\n          }}\n        >\n          <LetterGlitch glitchSpeed={50} centerVignette={false} outerVignette={false} smooth characters=\". \" />\n          <div className=\"absolute inset-0 pointer-events-none\">\n            <div className=\"absolute top-0 left-0 w-full h-16 bg-gradient-to-b from-black/90 via-black/70 to-transparent blur-lg\"></div>\n            <div className=\"absolute bottom-0 left-0 w-full h-16 bg-gradient-to-t from-black/90 via-black/70 to-transparent blur-lg\"></div>\n            <div className=\"absolute top-0 left-0 w-16 h-full bg-gradient-to-r from-black/90 via-black/70 to-transparent blur-lg\"></div>\n            <div className=\"absolute top-0 right-0 w-16 h-full bg-gradient-to-l from-black/90 via-black/70 to-transparent blur-lg\"></div>\n          </div>\n        </div>\n        \n        {/* Edge Vignette */}\n        <div className=\"absolute inset-0 z-30 pointer-events-none\">\n          <div className=\"absolute inset-0 shadow-[inset_0_0_80px_rgba(0,0,0,0.8)]\"></div>\n        </div>\n\n        {/* Subtle blue radial glow on black */}\n        <div\n          className=\"absolute inset-0 z-0\"\n          style={{\n            background:\n              'radial-gradient(ellipse 80% 60% at 50% 50%, rgba(120,180,255,0.15), transparent 70%), #000'\n          }}\n        />\n\n        {/* Foreground content */}\n        <div className=\"relative z-20 flex flex-col items-center justify-center h-full\">\n          <div className=\"mb-4\">\n            {status === 'running' ? (\n              <div className=\"w-8 h-8 drop-shadow-[0_0_8px_rgba(120,180,255,0.4)]\">\n                <CustomLoader size=\"md\" />\n              </div>\n            ) : (\n              <Monitor className=\"w-8 h-8 text-white/60 drop-shadow-[0_0_8px_rgba(156,163,175,0.3)]\" />\n            )}\n          </div>\n\n          <AnimatePresence mode=\"wait\">\n            <motion.p\n              key={currentStage.key + status}\n              initial={{ opacity: 0, y: 10 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: -10 }}\n              transition={{ duration: 0.3 }}\n              className=\"text-sm font-bold text-center text-white mb-4 drop-shadow-[0_0_6px_rgba(229,231,235,0.2)]\"\n            >\n              {getStatusText()}\n            </motion.p>\n          </AnimatePresence>\n\n          {(status === 'running' || status === 'queued' || status === 'succeeded') && (\n            <AsciiProgressBar progress={finalProgress} />\n          )}\n        </div>\n      </div>\n    </div>\n  )\n}\n\n/* ────────────── Section Wrapper ────────────── */\nexport default function ProcessingCardSection() {\n  const [progress, setProgress] = React.useState(0)\n  const [status, setStatus] = React.useState<'queued' | 'running' | 'succeeded' | 'failed'>('running')\n\n  React.useEffect(() => {\n    const interval = setInterval(() => {\n      setProgress(prev => {\n        if (prev >= 100) {\n          setStatus('succeeded')\n          clearInterval(interval)\n          return 100\n        }\n        return prev + Math.random() * 3 + 1\n      })\n    }, 300)\n\n    return () => clearInterval(interval)\n  }, [])\n\n  return (\n    <section className=\"relative w-full min-h-screen bg-black text-white overflow-hidden\">\n      {/* Subtle vignette */}\n      <div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(ellipse_80%_60%_at_50%_40%,rgba(120,180,255,0.08),transparent_70%)]\" />\n      \n      {/* Centered Card */}\n      <div className=\"min-h-screen w-full flex items-center justify-center px-4 py-20\">\n        <div className=\"w-full max-w-[632px]\">\n          <ProcessingCard \n            status={status}\n            progress={progress}\n            name=\"ComponentGeneration\"\n            glitchOffsetX={150}\n            glitchOffsetY={170}\n            glitchScale={1.6}\n            cardWidth={600}\n            cardHeight={550}\n          />\n        </div>\n      </div>\n    </section>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}