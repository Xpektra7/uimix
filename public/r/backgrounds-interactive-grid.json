{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "backgrounds-interactive-grid",
  "type": "registry:block",
  "title": "Backgrounds Interactive Grid",
  "description": "Interactive moving grid background with hover glow and noise",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/backgrounds-interactive-grid.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef } from \"react\";\ntype Offset = { x: number; y: number };\n\nconst setHiDPICanvas = (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => {\n  const parent = canvas.parentElement;\n  const cw = (parent?.clientWidth ?? window.innerWidth) | 0;\n  const ch = (parent?.clientHeight ?? window.innerHeight) | 0;\n  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));\n\n  canvas.width = Math.floor(cw * dpr);\n  canvas.height = Math.floor(ch * dpr);\n  canvas.style.width = cw + \"px\";\n  canvas.style.height = ch + \"px\";\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nconst originFromOffset = (offset: Offset, cell: number) => ({\n  x: -((offset.x % cell) + cell) % cell,\n  y: -((offset.y % cell) + cell) % cell,\n});\n\nconst Noise: React.FC<{ refresh?: number; alpha?: number }> = ({ refresh = 2, alpha = 18 }) => {\n  const ref = useRef<HTMLCanvasElement | null>(null);\n\n  useEffect(() => {\n    const c = ref.current;\n    if (!c) return;\n    const ctx = c.getContext(\"2d\", { alpha: true });\n    if (!ctx) return;\n\n    let f = 0;\n    let id = 0;\n    const S = 1024;\n\n    const resize = () => {\n      c.width = S;\n      c.height = S;\n      c.style.width = \"100vw\";\n      c.style.height = \"100vh\";\n    };\n\n    const draw = () => {\n      const img = ctx.createImageData(S, S);\n      const d = img.data;\n      for (let i = 0; i < d.length; i += 4) {\n        const v = Math.random() * 255;\n        d[i] = v as any;\n        d[i + 1] = v as any;\n        d[i + 2] = v as any;\n        d[i + 3] = alpha as any;\n      }\n      ctx.putImageData(img, 0, 0);\n    };\n\n    const loop = () => {\n      if (f % refresh === 0) draw();\n      f++;\n      id = requestAnimationFrame(loop);\n    };\n\n    addEventListener(\"resize\", resize);\n    resize();\n    loop();\n    return () => {\n      removeEventListener(\"resize\", resize);\n      cancelAnimationFrame(id);\n    };\n  }, [refresh, alpha]);\n\n  return (\n    <canvas\n      ref={ref}\n      className=\"pointer-events-none absolute inset-0\"\n      style={{ imageRendering: \"pixelated\" }}\n    />\n  );\n};\n\ninterface GridProps {\n  squareSize: number;\n  borderColor: string;\n  vignette?: boolean;\n  gridOffsetRef: React.MutableRefObject<Offset>;\n  className?: string;\n}\n\nconst MovingGrid: React.FC<GridProps> = ({\n  squareSize,\n  borderColor,\n  vignette = true,\n  gridOffsetRef,\n  className = \"\",\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const raf = useRef<number>();\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    const draw = () => {\n      const cw = canvas.clientWidth;\n      const ch = canvas.clientHeight;\n      ctx.clearRect(0, 0, cw, ch);\n\n      const origin = originFromOffset(gridOffsetRef.current, squareSize);\n\n      ctx.strokeStyle = borderColor;\n      for (let x = origin.x; x < cw + squareSize; x += squareSize) {\n        ctx.beginPath();\n        ctx.moveTo(x + 0.5, 0);\n        ctx.lineTo(x + 0.5, ch);\n        ctx.stroke();\n      }\n      for (let y = origin.y; y < ch + squareSize; y += squareSize) {\n        ctx.beginPath();\n        ctx.moveTo(0, y + 0.5);\n        ctx.lineTo(cw, y + 0.5);\n        ctx.stroke();\n      }\n\n      if (vignette) {\n        const grad = ctx.createRadialGradient(\n          cw / 2,\n          ch / 2,\n          0,\n          cw / 2,\n          ch / 2,\n          Math.sqrt(cw * cw + ch * ch) / 2\n        );\n        grad.addColorStop(0, \"rgba(0,0,0,0)\");\n        grad.addColorStop(1, \"#060010\");\n        ctx.fillStyle = grad;\n        ctx.fillRect(0, 0, cw, ch);\n      }\n\n      raf.current = requestAnimationFrame(draw);\n    };\n\n    const resize = () => setHiDPICanvas(canvas, ctx as any);\n    resize();\n    raf.current = requestAnimationFrame(draw);\n    addEventListener(\"resize\", resize);\n    return () => {\n      removeEventListener(\"resize\", resize);\n      if (raf.current) cancelAnimationFrame(raf.current);\n    };\n  }, [squareSize, borderColor, vignette, gridOffsetRef]);\n\n  return <canvas ref={canvasRef} className={`block h-full w-full border-none ${className}`} />;\n};\n\ninterface HoverProps {\n  squareSize: number;\n  hoverFillColor: string | CanvasGradient | CanvasPattern;\n  hoverStrokeColor: string | CanvasGradient | CanvasPattern;\n  hoverGlowColor: string | CanvasGradient | CanvasPattern;\n  gridOffsetRef: React.MutableRefObject<Offset>;\n  className?: string;\n}\n\nconst SquaresInteractive: React.FC<HoverProps> = ({\n  squareSize,\n  hoverFillColor = \"rgba(37,99,235,0.25)\",\n  hoverStrokeColor = \"rgba(37,99,235,0.8)\",\n  hoverGlowColor = \"rgba(37,99,235,0.45)\",\n  gridOffsetRef,\n  className = \"\",\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const hoveredRef = useRef<{ x: number; y: number } | null>(null);\n  const raf = useRef<number>();\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    canvas.style.pointerEvents = \"auto\";\n    canvas.style.cursor = \"crosshair\";\n    canvas.style.background = \"transparent\";\n\n    const draw = () => {\n      const cw = canvas.clientWidth;\n      const ch = canvas.clientHeight;\n      ctx.clearRect(0, 0, cw, ch);\n\n      if (hoveredRef.current) {\n        const { x: gx, y: gy } = hoveredRef.current;\n        const origin = originFromOffset(gridOffsetRef.current, squareSize);\n\n        const cellX = origin.x + gx * squareSize;\n        const cellY = origin.y + gy * squareSize;\n\n        ctx.save();\n        ctx.shadowBlur = 18;\n        ctx.shadowColor = hoverGlowColor as string;\n        ctx.fillStyle = hoverFillColor as string;\n        ctx.fillRect(cellX, cellY, squareSize, squareSize);\n        ctx.restore();\n\n        ctx.lineWidth = 1.25;\n        ctx.strokeStyle = hoverStrokeColor as string;\n        ctx.strokeRect(cellX + 0.5, cellY + 0.5, squareSize - 1, squareSize - 1);\n\n        const grad = ctx.createLinearGradient(cellX, cellY, cellX, cellY + squareSize);\n        grad.addColorStop(0, \"rgba(255,255,255,0.20)\");\n        grad.addColorStop(1, \"rgba(255,255,255,0.05)\");\n        ctx.fillStyle = grad;\n        ctx.fillRect(cellX, cellY, squareSize, squareSize);\n      }\n\n      raf.current = requestAnimationFrame(draw);\n    };\n\n    const onMouseMove = (e: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      const origin = originFromOffset(gridOffsetRef.current, squareSize);\n      const gx = Math.floor((mouseX - origin.x) / squareSize);\n      const gy = Math.floor((mouseY - origin.y) / squareSize);\n      hoveredRef.current = { x: gx, y: gy };\n    };\n\n    const onMouseLeave = () => {\n      hoveredRef.current = null;\n    };\n\n    const resize = () => {\n      setHiDPICanvas(canvas, ctx as any);\n    };\n\n    resize();\n    raf.current = requestAnimationFrame(draw);\n\n    addEventListener(\"resize\", resize);\n    canvas.addEventListener(\"mousemove\", onMouseMove);\n    canvas.addEventListener(\"mouseleave\", onMouseLeave);\n\n    return () => {\n      removeEventListener(\"resize\", resize);\n      canvas.removeEventListener(\"mousemove\", onMouseMove);\n      canvas.removeEventListener(\"mouseleave\", onMouseLeave);\n      if (raf.current) cancelAnimationFrame(raf.current);\n    };\n  }, [squareSize, hoverFillColor, hoverStrokeColor, hoverGlowColor, gridOffsetRef]);\n\n  return <canvas ref={canvasRef} className={`block h-full w-full border-none ${className}`} />;\n};\n\ntype Direction = \"right\" | \"left\" | \"up\" | \"down\" | \"diagonal\";\n\ninterface CombinedProps {\n  showGrid?: boolean;\n  direction?: Direction;\n  speed?: number;\n  squareSize?: number;\n  borderColor?: string;\n  vignette?: boolean;\n  hoverFillColor?: string;\n  hoverStrokeColor?: string;\n  hoverGlowColor?: string;\n  className?: string;\n}\n\nexport default function BackgroundInteractiveGrid({\n  showGrid = true,\n  direction = \"diagonal\",\n  speed = 0.6,\n  squareSize = 44,\n  borderColor = \"rgba(255,255,255,0.12)\",\n  vignette = true,\n  hoverFillColor = \"rgba(37,99,235,0.03)\",\n  hoverStrokeColor = \"rgba(148,163,184,0.10)\",\n  hoverGlowColor = \"rgba(37,99,235,0.15)\",\n  className = \"\",\n}: CombinedProps) {\n  const gridOffsetRef = useRef<Offset>({ x: 0, y: 0 });\n  const raf = useRef<number>();\n\n  useEffect(() => {\n    const tick = () => {\n      const v = Math.max(speed, 0.1);\n      const s = squareSize;\n      switch (direction) {\n        case \"right\":\n          gridOffsetRef.current.x = (gridOffsetRef.current.x - v + s) % s;\n          break;\n        case \"left\":\n          gridOffsetRef.current.x = (gridOffsetRef.current.x + v + s) % s;\n          break;\n        case \"up\":\n          gridOffsetRef.current.y = (gridOffsetRef.current.y + v + s) % s;\n          break;\n        case \"down\":\n          gridOffsetRef.current.y = (gridOffsetRef.current.y - v + s) % s;\n          break;\n        case \"diagonal\":\n        default:\n          gridOffsetRef.current.x = (gridOffsetRef.current.x - v + s) % s;\n          gridOffsetRef.current.y = (gridOffsetRef.current.y - v + s) % s;\n          break;\n      }\n      raf.current = requestAnimationFrame(tick);\n    };\n    raf.current = requestAnimationFrame(tick);\n    return () => {\n      if (raf.current) cancelAnimationFrame(raf.current);\n    };\n  }, [direction, speed, squareSize]);\n\n  return (\n    <div className={`fixed inset-0 z-50 bg-neutral-950 ${className}`}>\n      <div className=\"absolute inset-0 z-0 bg-[radial-gradient(circle_620px_at_50%_200px,rgba(37,99,235,0.35),transparent_70%)]\" />\n      {showGrid && (\n        <div className=\"absolute inset-0 z-10\">\n          <MovingGrid\n            squareSize={squareSize}\n            borderColor={borderColor}\n            vignette={vignette}\n            gridOffsetRef={gridOffsetRef}\n          />\n        </div>\n      )}\n      <div className=\"absolute inset-0 z-20\">\n        <SquaresInteractive\n          squareSize={squareSize}\n          hoverFillColor={hoverFillColor}\n          hoverStrokeColor={hoverStrokeColor}\n          hoverGlowColor={hoverGlowColor}\n          gridOffsetRef={gridOffsetRef}\n        />\n      </div>\n      <div className=\"pointer-events-none absolute inset-0 z-30\">\n        <Noise refresh={2} alpha={18} />\n      </div>\n      <div className=\"pointer-events-none absolute inset-0 z-40 bg-gradient-to-b from-transparent via-transparent to-black/60\" />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}